# LISTA OFICIAL DE TAREAS “LENGUAJES DE PROGRAMACIÓN”.

Jorge Eduardo Ortiz Triviño
Profesor Asociado DISI
Última actualización: Domingo 26 de mayo de

- Tarea 1: Video de Presentación.
- Tarea 2: Clasificación de los lenguajes de programación.
- Tarea 3: Tareas esenciales de un lenguaje ensamblador.
- Tarea 4: Diseño de la calculadora de Stibitz.
- Tarea 5: Construcción de la calculadora de Stibitz.
- Tarea 6: Implementación del Test de Miller-Rabin.
- Tarea 7: Diseño de un tipo de dato para grandes números y estimación de PI.
- Tarea 8: Errores a través de los módulos de un compilador.
- Tarea 9: Máquina de diferencias.
- Tarea 10: ¿Cómo se inventaron los números imaginarios?
- Tarea 11: Ampliación y mejoramiento del computador propuesto por el Prof. Peña.
- Tarea 12: Decompilador.
- Tarea 13: Computación cuántica: Implementación del algoritmo de búsqueda de Grovers.
- Tarea 14: VHDL y Hardware evolutivo.
- Tarea 15: Repertorio de microinstrucciones para un computador neuronal.
- Tarea 16: Computador virtual sobre un sistema de red Ad Hoc.
- Tarea 17: Presente, pasado y futuro simples en un idioma artificial.
- Tarea 18: Emulación en VHDL del computador que extiende la máquina del Prof. Peña.
- Tarea 19: Placa o circuito del computador que extiende la máquina del Prof. Peña.
- Tarea 20: Vocabulario para una calculadora aritmética sencilla.
- Tarea 21: Plural expresivo.
- Tarea 22: Lenguajes regulares vs. Lenguajes NO regulares.
- Tarea 23: Equivalencia de expresiones regulares caso sencillo.
- Tarea 24: Equivalencia de expresiones regulares caso un poco menos sencillo.
- Tarea 25: Patrón para reconocer identificadores en un lenguaje de programación hipotético.
- Tarea 26: Demostración de una ley algebraica de las expresiones regulares.
- Tarea 27: Patrón para reconocer números complejos.
- Tarea 28: Compilación y ejecución ejemplos en FLEX.
- Tarea 29: Completar, compilar y ejecutar el analizador para la estructura de selección.
- Tarea 30: Ampliar el analizador léxico para la «selección» agregándole la estructura «while».
- Tarea 31: Implementación de la distancia Damerau-Levenshtein en Excel.
- Tarea 32: Implementación de la distancia Damerau-Levenshtein en C++
- Tarea 33: Propuesta de una función de distancia propia para lenguajes.
- Tarea 34: Distancia en el ámbito semántico...
- Tarea 35: Deducción de un lenguaje dada una gramática.
- Tarea 36: Gramática libre de contexto para una calculadora aritmética simple.
- Tarea 37: Determinar la GLC para una expresión regular.
- Tarea 38: Diseño de un lenguaje de programación para un modelo de programación lineal.
- Tarea 39: Diseño de un lenguaje de programación para expresiones booleanas.
- Tarea 40: Lenguaje de programación para un “nuevo paradigma de programación”.

Observaciones generales sobre las tareas:

1. Para todas las tareas automatizadas que requieran construir programas y aplicaciones está únicamente permitido emplear:
   1. a. Lenguaje de programación y librerías que se incluyan en la instalación estándar de dicho lenguaje, ninguna otra librería o herramienta puede usarse, salvo la que se describe en el siguiente numeral.
   2. b. Una librería especializada de estructuras de datos seleccionada libremente por el estudiante que realiza la tarea.
   3. c. Por tanto, cuando requiera usar alguna herramienta o librería no incluida en la instalación estándar, el estudiante debe solicitar permiso para su uso, pero en ningún caso se aceptan librerías que ya traigan resulto el problema propuesto.
2. Aunque los mapas conceptuales corresponden a tareas manuscritas, éstos pueden realizarse o bien de forma manual (lápiz y papel) o bien mediante alguna aplicación informática diseñada para tal fin.

## Tarea 1: Video de Presentación.

```
Inicio: 06 de febrero de 2024. 
Categoría: Automatizada.
Entrega: 8:00 pm miércoles 07 de febrero de 2024. 
Dificultad: 0
Tipo: Obligatoria 
Clase: 01
Número de estudiantes: 1
```

### Enunciado:

Realización de un video en el cual cada uno de los estudiantes del curso, de manera libre e individual, se
presenta ante los integrantes del curso. Este video, cuya duración tiene que estar entre 20 seg. y 30 seg.,
debe subirse a YouTube.

### Observaciones:

1. Subir el video en formato estándar de YouTube (No el formato de videos cortos, es decir Short).
2. Configurar el video para que NO sea para un público infantil puesto que ello me permite agregarlo a mis listas de reproducción.
3. Formato del nombre del video: LP02 Presentación estudiante XXXX YYYY, donde las XXXX deben reemplazarse por sus apellidos y las YYYY deben reemplazarse por sus nombres (tal como aparecen en el SIA).
4. Esta tarea se entiende entregada una vez se responda el correo electrónico enviado para tal fin con el enlace de YouTube.

## Tarea 2: Clasificación de los lenguajes de programación.

```
Inicio: 08 de febrero de 2024. 
Categoría: Manuscrita.
Entrega: Antes del primer parcial. 
Dificultad: 0
Tipo: Obligatoria
Clase: 02
Número de estudiantes: 1
```

### Enunciado:

Indique cuales de los siguientes términos:

* a. Imperativo.
* b. Orientado a objetos.
* c. Cuarta generación.
* d. Declarativo.
* e. Funcional.
* f. Scripting.
* g. Von Neumann.
* h. Tercera generación.

Aplican a cada uno de los siguientes lenguajes de programación:

1. C
2. C++
3. Cobol
4. Fortran.
5. Java
6. Lisp.
7. ML
8. Perl.
9. Python.
10. VB

## Tarea 3: Tareas esenciales de un lenguaje ensamblador.

```
Inicio: 08 de febrero de 2024. 
Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. 
Dificultad: 0
Tipo: Obligatoria 
Clase: 02
Número de estudiantes: 1
```

Enunciado:

Realice una lista (lo más exhaustiva posible) de las tareas que debe realizar un lenguaje ensamblador.

## Tarea 4: Diseño de la calculadora de Stibitz.

```
Inicio: 1 3 de febrero de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria Clase: 03
Número de estudiantes: 1
```

Enunciado:

1. Vea con detenimiento el video “Por Qué Las Primeras Computadoras Estaban Hechas De
   Bombillas” del Dr. Muller del canal de YouTube Veritasium que pueden encontrar a través del
   enlace https://youtu.be/LvhhcsLrHDw.
2. El mundo de la computación digital nace realmente con la construcción, en 1937, de la calculadora
   de George Stibitz. Por ello, para la realización de esta tarea se pide presentar el diagrama del

```
circuito de esa máquina y acompañarlo con una pequeña, pero completa explicación de su
funcionamiento.
```

## Tarea 5: Construcción de la calculadora de Stibitz.

```
Inicio: 1 3 de febrero de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 1
Tipo: Opcional Clase: 03
Número de estudiantes: 2
```

Enunciado:

Construya con bombillos, baterías y Relays la calculadora de George Stibitz cuyo diseño se realizó en la
Tarea 4.

## Tarea 6: Implementación del Test de Miller-Rabin.

```
Inicio: 15 de febrero de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 1
Tipo: Opcional Clase: 04
Número de estudiantes: 3
```

Enunciado:

Análisis diseño e implementación del Test de Miller-Rabin para determinar si un número de más de 100
dígitos es primo (acompañe al resultado la probabilidad estimada de la validez del resultado).

Observaciones:

Hay libertad para que el estudiante seleccione el lenguaje de programación que, con su criterio de
ingeniero, considere pertinente.

## Tarea 7: Diseño de un tipo de dato para grandes números y estimación de PI.

```
Inicio: 15 de febrero de 2024. Categoría: Manuscrita.
```

```
Entrega: Medianoche del día anterior al parcial. Dificultad: 1
Tipo: Obligatoria. Clase: 04
Número de estudiantes: 3
```

Enunciado:

1. Diseñar con detalle un tipo de dato que permita gestionar números reales con un número arbitrario
   de dígitos decimales y realizar operaciones básicas como suma, multiplicación, división,
   potenciación entre ellos.
2. Diseñar una aplicación que permita calcular el numero PI con un número de dígitos dado a partir
   de la serie de Ramanujan. Véase la sección “Logros matemáticos” de la página:
   https://es.wikipedia.org/wiki/Srinivasa_Ramanujan.

Observaciones:

- Emplee UML para presentar sus diseños.
- Puede usarse una herramienta de software que permita construir los diseños solicitados.

## Tarea 8: Errores a través de los módulos de un compilador.

```
Inicio: 15 de febrero de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 04
Número de estudiantes: 2
```

Enunciado:

Teniendo en cuenta su (gran) experiencia en el arte de programar, identifique al menos tres tipos de errores
que se presentan en cada uno de los módulos que componen un compilador. Describa con detalle en qué
consiste el error y describa (en lenguaje natural) cómo puede el módulo detectar el error y cómo debería
gestionarlo.

## Tarea 9: Máquina de diferencias.

```
Inicio: 15 de febrero de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 05
Número de estudiantes: 2
```

Enunciado:

Análisis, diseño y construcción del método de diferencias para aproximación de polinomios empleado
por Caharle Babbage. El método recibe el polinomio, internamente construye la tabla de diferencias y la
usa cuando se le invoca para estimar el valor del polinomio para un valor de X determinado.

Observaciones:

- El lenguaje de desarrollo que DEBE emplear es C#.

## Tarea 10: ¿Cómo se inventaron los números imaginarios?

```
Inicio: 15 de febrero de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 05
Número de estudiantes: 1
```

Enunciado:

A veces no somos conscientes de los tortuosos caminos por los que ha tenido que atravesar la humanidad
para consolidar ciertos conceptos matemáticos. Un ejemplo lo encontramos en los números complejos
... ¿y para qué sirve esto en el diseño de lenguajes de programación? No lo sé, pero la historia tiene su
encanto intelectual, así que no importa ...

1. Deben ver el video ¿Cómo se inventaron los números imaginarios? Del Dr. Muller del canal de
   YouTube Veritasium y que pueden encontrar a través del enlace:
   https://youtu.be/VN7nipynE0c?si=-z0hWIkQ3HI07WLf.
2. Realizar un mapa conceptual del contenido del video (este mapa es el entregable de esta tarea).

## Tarea 11: Ampliación y mejoramiento del computador propuesto por el Prof. Peña.

```
Inicio: 22 de febrero de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 06
Número de estudiantes: 1
```

Enunciado:

1. Con base en los diseños del computador presentados en la sección 2.5 cómo funciona un
   computador, del libro De Euclides a Java escrito por Ricardo Peña, haga los ajustes y diseños
   necesarios de esa máquina para convertirla en una de palabras de 32 o 64 bits y que incluya
   dispositivos de entrada-salida, buses y comunicaciones, incluya otras instrucciones típicas del
   lenguajes de máquina que haya omitido el profesor Peña y las que requiera para poder gestionar
   los nuevos dispositivos que usted le ha agregado. Debe garantizar que los códigos de las
   instrucciones, los registros y de más elementos se realice de forma no ambigua cuando el código
   se lee de izquierda a derecha.
2. Programe el algoritmo de Euclides iterativo que reciba los datos de entrada, desde un archivo y
   deje el resultado en otro archivo, ambos almacenados en disco.

## Tarea 12: Decompilador.

```
Inicio: 22 de febrero de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 06
Número de estudiantes: 2
```

Enunciado:

A partir del código de máquina, dado por el Prof. Peña en la sección 2.5, obtenido para el algoritmo de
Euclides, obtenga el código de máquina relocalizable (reubicable o relativo) del mismo problema.

## Tarea 13: Computación cuántica: Implementación del algoritmo de búsqueda de Grovers.

```
Inicio: 22 de febrero de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 06
Número de estudiantes: 2
```

Enunciado:

1. Vea el video “Cómo se programa un ORDENADOR CUÁNTICO (bien explicado)” de Antonio
   Párraga que pueden encontrar a través del enlace
   https://youtu.be/eRlQdW1lgJE?si=QuTYgOsJW8-5R8pT.
2. Vale la pena visitar, ver, entender y correr los ejemplos y técnicas de Programación Cuántica que
   de forma sencilla y didáctica se presentan en el canal de YouTube Ket.G
   (https://www.youtube.com/channel/UCedVPGH5fnWBmsR4oHVOX6w). En particular, pueden
   consultar la lista de reproducción
   https://www.youtube.com/watch?v=RXfmP7eaV5s&list=PLhYoqmIacCv--
   V8DGX2Wpw_M8w6XGOtB0&pp=iAQB que contiene varios videos de programación cuántica
   (pero les sugiero también ver los capítulos de fundamentación teórica para poder entender mejor
   y más rápido).
3. Vea el video “Running an experiment in the IBM Quantum Experience” que localizan mediante
   el enlace https://youtu.be/pYD6bvKLI_c?si=X3i0HIBwk7xr4YAG.
4. Regístrese y familiarícese con el sitio IBM Quantum Experience, a través del enlace
   https://quantum-computing.ibm.com/. Conozca más de la configuración técnica de los
   procesadores Eagle y Condor.
5. Emplee el SDK Qiskit, que pueden obtener a través del enlace https://qiskit.org/, para implementar
   **_“El algoritmo de búsqueda de Grovers (Grover’s search algooriothm)”_** en un programa cuántico.
   También puede emplear un SDK diferente. En
   https://www.microsiervos.com/archivo/ordenadores/hola-mundo-siete-lenguajes-programacion-
   cuantica.html hay 7 lenguajes de programación cuántica recomendados.
6. Ejecutar el programa en un computador Cuántico de IBM y hacer el análisis de resultados.

## Tarea 14: VHDL y Hardware evolutivo.

```
Inicio: 22 de febrero de 2024. Categoría: manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 06
Número de estudiantes: 1
```

Enunciado:

1. Vea el video “¿Qué es VHDL?” del canal de YouTube MindMachineTV. El video lo encuentran
   a través del enlace https://youtu.be/XFyu9JhG7Nw?si=-YUW0eV-DUYXJ6Z4.
2. Realice un mapa conceptual del tema expuesto en el video del numeral 1.
3. Vea el video “¿Qué es un FPGA?” del canal de YouTube MindMachineTV. El video lo
   encuentran a través del enlace https://youtu.be/unERWj2lOvA?si=EZSp31hqF4Fkbkv3.
4. Realice un mapa conceptual del tema expuesto en el video del numeral 3.
5. En un párrafo de no más de 250 palabras proponga cómo se pueden emplear los algoritmos
   genéticos y la programación genética para hacer que el “hardware” sea quien evolucione. Se
   denomina “Hardware evolutivo” a la técnica de combinar circuitos digitales que se pueden
   programar en lenguajes como VHDL, se ponen en evolución mediante programación genética
   para, por ejemplo, optimizarlos u obtener nuevas funcionalidades sofisticadas y, finalmente se
   emulan o se “queman” en dispositivos (tarjetas) electrónicas flexibles como los FPGA. ¡Una
   compleja obra de ingeniería que requiere de lenguajes!

## Tarea 15: Repertorio de microinstrucciones para un computador neuronal.

```
Inicio: 22 de febrero de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 06
Número de estudiantes: 1
```

Enunciado:

1. Vea el video El Futuro de las Computadoras Será Radicalmente Diferente, del canal de YouTube
   Veritasium (que pueden acceder a través del enlace:
   https://youtu.be/qNtxODk_Lmk?si=a7H_VLsVMvkVJLXU).
2. Vea el video Las Computadoras Superpoderosas de las que Nunca te Contaron, del canal de
   YouTube Veritasium (que pueden acceder a través del enlace:
   https://youtu.be/PQeS7sfMxR4?si=G7xTHzN83kOotwOH).
3. Proponga un conjunto de (micro) instrucciones elementales (al estilo de las microinstrucciones de
   la arquitectura von Neumann) que le permitirían manejar y gestionar un computador neuronal.

## Tarea 16: Computador virtual sobre un sistema de red Ad Hoc.

```
Inicio: 27 de febrero de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 07
Número de estudiantes: 1
```

Contexto:

Cada nodo en un sistema Ad Hoc aporta una “pequeña" máquina John von Neumann”. Esas pequeñas
máquinas "dispersas" son integradas mediante un sistema virtualizado de tal manera que pueden operar
como un "gran computador John von Neumann" en el cual, por ejemplo, el almacenamiento secundario
puede verse como un gran disco cuya capacidad bruta es la suma de las capacidades de las porciones de
disco físico que cada nodo ha aportado al sistema y de forma similar con los demás elementos que
componen una arquitectura John von Neumann. En una arquitectura John von Neumann clásica el
fabricante incluye, además del hardware, un lenguaje ensamblador que permite explotar las capacidades
de cómputo de la máquina que ofrece. A cada instrucción de ese lenguaje ensamblador se le denomina
"microinstrucción". Para la máquina virtual John von Neumann que se puede construir sobre un sistema
de red Ad Hoc a esas instrucciones que permiten explotar las capacidades de cómputo de este sistema de
cómputo virtual (computador distribuido) las llamaremos "microservicios".

Enunciado:

1. Suponga que cuenta con cinco (5) de sus máquinas diseñadas en la Tarea 11 , de manera
   esquemática general, suponga que ellas conforman una Red Ad Hoc (Los detalles de convertir 5
   nodos en una Red Ad Hoc son, por supuesto complejos, pero aquí solamente debe suponer que ya
   puede intercambiar de forma fiable mensajes entre las diferentes máquinas).
2. Haga los diseños (estos sí detallados) de un computador John von Neumann virtual de 32 bits
   (JvN 32 bits) sobre sobre esa Red Ad Hoc.
3. Presente el análisis y los diseños detallados del repertorio de instrucciones (como mínimo 25
   microservicios que Usted, como fabricante de ese computador virtual, entrega como parte de ese
   sistema de cómputo distribuido. Los microservicios diseñados deben estar en por lo menos tres de
   las siguientes categorías de gestión del computador virtual:
   a. Memoria (registros virtuales, cache virtual, RAM virtual, etc),
   b. Procesamiento (Unidad aritmética virtual, CPU virtual, etc),
   c. Unidades de entrada/Salida virtuales y
   d. Comunicaciones virtuales.
   e. Comunicaciones subsistema virtual-Subsistema físico (local de cada máquina que
   conforma la red y la red en sí misma).
4. De forma similar a como el Prof. Peña empleó el algoritmo de Euclides para mostrar el
   funcionamiento de su máquina de la sección 2.5 Cómo funciona un computador del libro De
   Euclides a Java, seleccione un algoritmo típico en computación distribuida y ejemplifique con él
   el funcionamiento de su computador JvN Virtual.

## Tarea 17: Presente, pasado y futuro simples en un idioma artificial.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
```

```
Tipo: Obligatoria. Clase: 07
Número de estudiantes: 1
```

Contexto:

El grupo de investigación TLÖN tiene como uno de sus grandes objetivos construir sociedades artificiales
(que extiende o generaliza el concepto de sistemas multiagentes). Una sociedad artificial está conformada
por agentes comunicantes esa distinción requiere que los agentes puedan manejar e interpretar uno (o
más) idioma (s) para “hablarse” y “comprenderse” entre ellos. Para poder implementar los módulos
correspondientes al sentido de la ubicación temporal de dichos agentes el grupo de ingenieros requiere
que el idioma artificial con que van a dotar a sus agentes permita la conjugación de los verbos en pasado
simple, presente y futuro simple. Por ejemplo, en idioma Castellano, el verbo correr se conjugaría como
corrí, corro y correré para la primera persona del singular. El grupo, sabiendo que usted es experto en
lenguajes y que es un verdadero creativo e innovador de la ingeniería de la computación, lo ha contratado
para que:

Enunciado:

Proponga una forma novedosa, ágil y muy eficiente para que, aplicando los conceptos de prefijo, sufijo,
subcadena y subsecuencia, el idioma artificial en construcción pueda incluir las ideas de pasado simple,
presente y futuro simple. En este punto debe explicar su propuesta en lenguaje cotidiano y mediante
ejemplos ilustrativos de cómo operaría algorítmicamente su propuesta.

Presente los diseños de sus ideas con diagramas de bloques, diagramas de flujo y pseudocódigo.

## Tarea 18: Emulación en VHDL del computador que extiende la máquina del Prof. Peña.

```
Inicio: 05 de marzo de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 2
Tipo: Opcional. Clase: 08
Número de estudiantes: 3
```

Enunciado:

Implemente detalladamente en VHDL el computador que ha dejado el desarrollo de la Tarea 11. Debe
incluir el análisis, diseño, implementación y conjunto de pruebas que muestren el correcto
funcionamiento del emulador (simulador) realizado, es decir, se trata de simular el diseño RTL.

## Tarea 19: Placa o circuito del computador que extiende la máquina del Prof. Peña.

```
Inicio: 05 de marzo de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 2
Tipo: Opcional. Clase: 08
Número de estudiantes: 3
```

Enunciado:

Implemente detalladamente en VHDL el computador que ha dejado el desarrollo de la Tarea 11. Es decir,
deben sinterizarlo (ya no emularlo, porque eso fue parte de la Tarea 18 ) y obtener el diseño (circuito) RTL
e implementarlo en un circuito o imprimirlo en una placa. Debe incluir el análisis, diseño,
implementación y conjunto de pruebas que muestren el correcto funcionamiento del computador en el
circuito en la placa según hayan optado por una u otra opción.

## Tarea 20: Vocabulario para una calculadora aritmética sencilla.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 09
Número de estudiantes: 1
```

Enunciado:

Suponga que se le ha encargado la construcción de una calculadora aritmética sencilla que, además de las
cuatro operaciones aritméticas básicas, pueda agrupar expresiones y también incluir potenciación. Por
ejemplo, un programa básico puede incluir un número ilimitado de líneas con operaciones como el
siguiente:

### 2 5 8+

```
( )
( )
```

```
1 3 1
2 5
```

(^73)
3.5 5.6 * (^11445)
(^29) 3 1.
+ −
+
+ −


1. Proponga el alfabeto apropiado para este tipo de lenguaje.
2. Proponga el vocabulario adecuado que le permita construir este lenguaje aritmético.
3. Realice el diccionario de términos del lenguaje solicitado.

## Tarea 21: Plural expresivo.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 09
Número de estudiantes: 1
```

Enunciado:

Deje volar su imaginación y, con base en el concepto de plural expresivo, muy propio del idioma español,
proponga una funcionalidad estructural (quizá exótica) que pudiera incluirse en un lenguaje de
programación (que, posiblemente, usted diseñe).

## Tarea 22: Lenguajes regulares vs. Lenguajes NO regulares.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 10
Número de estudiantes: 1
```

Enunciado:

## 1. Verificar que si =ab,  es un alfabeto y r=(ab)ies una expresión regular con i=0,1, 2,

## entonces Lr( ) es un lenguaje regular.

## 2. Sobre el mismo alfabeto =ab, proponga un lenguaje L que NO sea regular.

## Tarea 23: Equivalencia de expresiones regulares caso sencillo.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 10
Número de estudiantes: 1
```

Enunciado:

## 1. Determinar el lenguaje regular Lr( )generado por la expresión regular r=a a b*.

2. Encuentre una expresión regulars que sea equivalente a r.

## Tarea 24: Equivalencia de expresiones regulares caso un poco menos sencillo.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 10
Número de estudiantes: 1
```

Enunciado:

# 1. Determinar el lenguaje regular Lr( )generado por la expresión regular r=(a b* )*.

## 2. Determinar el lenguaje regular Lr( )generado por la expresión regular s=(a b b)*.

3. Demuestre (o refute) mediante el empleo de las leyes algebraicas de las expresiones regulares
   que rs.

## Tarea 25: Patrón para reconocer identificadores en un lenguaje de programación hipotético.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 10
Número de estudiantes: 1
```

Enunciado:

Suponga que, para implementar una funcionalidad a nivel semántico, los diseñadores de un lenguaje de
programación le solicitan a usted que, empleando únicamente la definición de expresión regular,
construya el patrón de reconocimiento de la categoría gramatical Identificador del lenguaje en
construcción cumpliendo dos restricciones básicas:

1. Los identificadores comienzan con letra (mayúscula o minúscula) y luego va una secuencia,
   posiblemente vacía, de dígitos o letras.
2. Todo identificador del lenguaje debe contener la subsecuencia TLON (bien sea en mayúsculas,
   minúsculas o combinación de ambas).

## Tarea 26: Demostración de una ley algebraica de las expresiones regulares.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 11
Número de estudiantes: 1
```

Enunciado:

Demostrar la ley algebraica de las expresiones regulares que establece que r sr( )**=(rs r).

## Tarea 27: Patrón para reconocer números complejos.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
```

```
Tipo: Obligatoria. Clase: 11
Número de estudiantes: 1
```

Enunciado:

Con base en Expresiones Regulares, Definiciones Regulares y Extensiones Regulares, construya el
patrón que permita reconocer al menos cinco (5) formas distintas de escribir los números complejos.

Observaciones:

1. Para tal fin deben consultar el PDF titulado “Números complejos: Compendio de conceptos y
   operaciones” alojado en nuestra biblioteca, y que pueden acceder directamente a través del enlace
   https://drive.google.com/file/d/1QR2E8lUxg9QLK27llBKuvPVeKd9hVl1t/view?usp=drive_link
   donde se presentan al menos 5 maneras diferentes de escribir un número complejo y se describen
   con detalle las principales operaciones entre números complejos.

## Tarea 28: Compilación y ejecución ejemplos en FLEX.

```
Inicio: 05 de marzo de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 12
Número de estudiantes: 1
```

Enunciado:

Comprender, compilar y ejecutar cada uno de los ejemplos incluidos en la carpeta
Programas_En_FLEX ubicada en la Biblioteca digital del curso. Para cada uno de los ejemplos deben
subir a sus buzones:

1. Comentarios sobre los principales ajustes que le tocó realizar para hacer correr el programa, y
2. Resultados de al menos tres ejecuciones del programa.

Observaciones:

1. Para tal fin deben consultar los ejemplos citados en la carpeta que pueden acceder directamente a
   través del enlace https://drive.google.com/drive/folders/1GAMtyq-
   BWOSQNfJLORFim6Z0udgZei93?usp=drive_link. Donde, además de los ejemplos, también
   encontrarán las instrucciones para descargar e instalar el meta compilador FLEX.

## Tarea 29: Completar, compilar y ejecutar el analizador para la estructura de selección.

```
Inicio: 05 de marzo de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 12
Número de estudiantes: 1
```

Enunciado:

Completar, compilar y ejecutar en el metalenguaje FLEX el analizador léxico para la estructura de
selección (if) de la Figura 3.23 ubicado en la página 166 del PDF del libro guía del curso Compilers:
Principles, Techniques, and Tools 2nd Edición de Alfred Aho, Monica Lam, Ravi Sethi y Jeffrey
Ullman que encontrarán en nuestra biblioteca digital o bien, directamente, mediante el enlace:
https://drive.google.com/file/d/1pKz8__-ywsd8nSYUGBEzcrMP6eSwk0Kz/view?usp=drive_link

1. El ejemplo de Aho define muy bien todas las categorías gramaticales de la estructura de selección
   presentada, PERO las palabras reservadas (Key Word, KW) no las agrupa (como debería ser) en
   una única categoría denominada “Palabra Reservada” (KW) (de forma similar a como sí lo hace
   con relop y sus elementos constitutivos). Defina las constantes manifiestas para esta categoría y
   para sus elementos constitutivos.
2. Para las otras categorías gramaticales (que ya están en el código presentado en el libro), codifique
   y defina apropiadamente las categorías gramaticales (léxicas) y sus elementos constitutivos que le
   permitan gestionar apropiadamente los retornos para cada una de ellas y devolver, mediante la
   variable yylval, el respectivo elemento constitutivo. Por ejemplo, para la categoría gramatical
   relop asignarles a las constantes manifiestas el valor 400 y al operador “Igual a” el valor 3.
3. Construya las tablas de símbolos para las categorías ID y NUMBER y diseñe e implemente las
   funciones InstallID e InstallNum.
4. Realice y documente al menos tres ejemplos de prueba para verificar el correcto funcionamiento
   del analizador léxico resultante para la estructura de selección.

## Tarea 30: Ampliar el analizador léxico para la «selección» agregándole la estructura «while».

```
Inicio: 05 de marzo de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 12
Número de estudiantes: 1
```

Enunciado:

Realizar el Exercise 3.5.1 del libro guía del curso Compilers: Principles, Techniques, and Tools 2nd
Edición de Alfred Aho, Monica Lam, Ravi Sethi y Jeffrey Ullman, ubicado en la página 16 9 del PDF
del libro. El libro se encuentra en nuestra biblioteca digital o bien, directamente, mediante el enlace:
https://drive.google.com/file/d/1pKz8__-ywsd8nSYUGBEzcrMP6eSwk0Kz/view?usp=drive_link.

Observación:

1. No es necesario, pero si deseable realizar la implementación y verificación de correcto
   funcionamiento. Se pide que lo resuelva con papel y lápiz e indicando claramente qué se debe
   hacer sobre el código.

## Tarea 31: Implementación de la distancia Damerau-Levenshtein en Excel.

```
Inicio: 05 de marzo de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 13
Número de estudiantes: 1
```

Enunciado:

Emplear una hoja de cálculo de Excel para obtener la distancia D-L. Usando Excel, implemente la
distancia D-L y pruébela con tres pares de palabras del idioma español. Mediante fórmulas el proceso
debe ser totalmente automático.

## Tarea 32: Implementación de la distancia Damerau-Levenshtein en C++

```
Inicio: 05 de marzo de 2024. Categoría: Automatizada.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 13
Número de estudiantes: 1
```

Enunciado:

Análisis, diseño e implementación de un programa en lenguaje de programación C++ que:

```
a. Reciba en un archivo el vocabulario (palabras reservadas) de un lenguaje de programación (p.e.
JAVA, C++, Python, etc).
b. Reciba un archivo escrito por un usuario (por ejemplo, un programa escrito en ese lenguaje).
c. Genere un nuevo archivo a partir del texto recibido que sustituya cada cadena (delimitadas por
espacios en blanco, tabuladores o cambios de línea) por la palabra reservada más cercana de
acuerdo con la distancia D-L.
```

## Tarea 33: Propuesta de una función de distancia propia para lenguajes.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 13
Número de estudiantes: 1
```

Enunciado:

Proponga una función de distancia d(L1, L2) de su autoría que reciba como argumento dos lenguajes de
programación, por ejemplo L1= C# y L2=Go, y devuelva un valor de distancia válido entre ellos.

## Tarea 34: Distancia en el ámbito semántico...

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 1
Tipo: Opcional. Clase: 13
Número de estudiantes: 1
```

Enunciado:

Proponga una función de distancia d(P1, P2) de su autoría en el espacio del sentido (ya no en el espacio
léxico como lo hace la distancia D-L) que reciba como argumento dos palabras en algún idioma (p.e. el
español) y devuelva un valor real que represente la distancia semántica entre las dos palabras. Por ejemplo,
d(amar, querer) o d(amor, odio).

## Tarea 35: Deducción de un lenguaje dada una gramática.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 14
Número de estudiantes: 1
```

Enunciado:

¿Cuál es el lenguaje generado o reconocido por la siguiente CFG? **<S> → a<S>a | aa**

## Tarea 36: Gramática libre de contexto para una calculadora aritmética simple.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 14
Número de estudiantes: 1
```

Enunciado:

Dada la gramática de la Figura 1 , diseñada para reconocer expresiones para una calculadora aritmética

simple:

```
Figura 1 : Gramática para una calculadora aritmética simple.
```

1. Determine las categorías léxicas y el vocabulario (palabras reservadas) implícitas en ella.
2. Verifique que es una gramática libre de contexto (GLC).
3. Verifique, por simple inspección, si la expresión: (X-Y) * (X/(Z-W)) es aceptada por dicha
   gramática.
4. Extienda la gramática de la **Figura 1** para que pueda recocer expresiones que incluyan
   identificadores y números reales (Por ejemplo, (3*X+5/Y) + X/(3-Z)).

## Tarea 37: Determinar la GLC para una expresión regular.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 17
Número de estudiantes: 1
```

Enunciado:

2. Proporcionar, si existe, una expresión regular r que reconozca el mismo lenguaje que la CFG <S>
   **→ <S> <P>; <S> → <P>**. De no existir, se deben argumentar las razones.
3. Dada la expresión regular p? escriba una CFG que reconozca el mismo lenguaje.

## Tarea 38: Diseño de un lenguaje de programación para un modelo de programación lineal.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 17
Número de estudiantes: 1
```

Enunciado:

Considere el modelo de programación lineal de la Figura 2 , ampliamente empleado en optimización.

```
Figura 2 : Un modelo de programación lineal.
```

1. Identifique las categorías gramaticales que requiere este modelo para su reconocimiento.
   Identifique las palabras reservadas que deben hacer parte del vocabulario.
2. Proponer una gramática libre de contexto CFG para reconocer el modelo de programación lineal
   (PL).
3. Proponer las reglas semánticas.
4. Usando una DDS (Definición dirigida por la sintaxis) o un ET (esquema de traducción) o ambos
   indique cómo realizaría la traducción a código intermedio.

## Tarea 39: Diseño de un lenguaje de programación para expresiones booleanas.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
Tipo: Obligatoria. Clase: 17
Número de estudiantes: 1
```

Enunciado:

Considere la GLC para expresiones booleanas de la Figura 3.

```
Figura 3 : Gramática libre de contexto para expresiones booleanas.
```

1. Verifique si corresponde a una CFG correcta y completa.
2. Seleccione tres expresiones booleanas (medianamente complejas) y, para ellas, argumente si la
   gramática las acepta o no las acepta.
3. Extienda la gramática de la **Figura 3** para que pueda recocer no solamente expresiones con true o
   false sino que pueda reconocer, además, expresiones proposicionales relacionales (Por ejemplo,
   (3X+5Y) <= X/(3-Z)).
4. Proponer las reglas semánticas.
5. Usando una DDS (Definición dirigida por la sintaxis) o un ET (esquema de traducción) o ambos
   indique cómo realizaría la traducción a código intermedio.

## Tarea 40: Lenguaje de programación para un “nuevo paradigma de programación”.

```
Inicio: 05 de marzo de 2024. Categoría: Manuscrita.
Entrega: Medianoche del día anterior al parcial. Dificultad: 0
```

```
Tipo: Obligatoria. Clase: 17
Número de estudiantes: 1
```

Enunciado:

Piense y proponga (no sobra decir que de su propia autoría) una “nueva forma de solucionar problemas
mediante algoritmos” (inspirándose en formas o paradigmas que se han presentado a lo largo de la
historia: Programación estructurada, Tipos de datos abstractos, programación orientada por objetos,
programación lógica, programación funcional, etc pero, obviamente, que no sea ninguna de ellas),:

1. Describa su idea en un par de párrafos de no más de 250 palabras en lenguaje cotidiano (en español)
   e incluya ejemplos que permitan evidenciar la bondad de su “nueva forma de solucionar
   problemas mediante algoritmos”.
2. Proponga el vocabulario de su le “nuevo” lenguaje.
3. Proponga una pequeña (pero representativa) gramática libre de contexto de al menos 20
   producciones relevantes.
4. Proponga un pequeño (pero significativo) conjunto de reglas semánticas coherentes con la
   gramática propuesta en el numeral anterior.
5. Presente dos pequeños, pero relevantes programas que pudieran correr en ese lenguaje.

---
